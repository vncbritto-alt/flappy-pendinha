<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy — Pendinha Games (Reset Total)</title>
<style>
  html,body{height:100%;margin:0;background:#70c5ce;display:flex;align-items:center;justify-content:center;font-family:Arial,Helvetica,sans-serif}
  .wrap{width:100%;max-width:460px;padding:14px;box-sizing:border-box}
  canvas{width:100%;height:auto;border-radius:8px;display:block;background:#70c5ce;border:0;box-shadow:0 8px 24px rgba(0,0,0,0.15)}
  .info{display:flex;justify-content:space-between;color:#042; margin-top:8px; font-weight:600}
  .hint{font-size:13px;color:#033; text-align:center; margin-top:8px}
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="320" height="480" aria-label="Flappy Pendinha"></canvas>
    <div class="info"><div>Pontos: <span id="points">0</span></div><div>Melhor: <span id="best">0</span></div></div>
    <div class="hint">Clique/Toque/Espaço → pular. Toque para iniciar depois do reset.</div>
  </div>

<script>
/* Flappy — Reset total ao colidir
   - Ao bater, salva highscore, reinicia totalmente (pontuação 0 + canos reposicionados)
   - Fica em pausa esperando o próximo clique/toque/Espaço para iniciar
*/

(function(){
  // Elementos
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // resolução interna
  const W = canvas.width = 320;
  const H = canvas.height = 480;

  // estado do jogo
  let bird = { x: 70, y: H/2, r: 12, vy: 0 };
  let gravity = 0.34, jump = -7.2;
  let pipes = []; // array de {x, top, bottom, passed}
  let gap = 120;
  let speed = 2.2;
  let frame = 0;
  let running = false; // se true, o jogo está em movimento
  let score = 0;
  let best = parseInt(localStorage.getItem('flappy_best') || '0', 10);

  // DOM
  const elPoints = document.getElementById('points');
  const elBest = document.getElementById('best');
  elPoints.textContent = score;
  elBest.textContent = best;

  // util
  const rand = (a,b) => Math.random()*(b-a)+a;
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  // cria cano em X
  function spawnPipeAt(x){
    const top = Math.floor(rand(40, H/2 - 20));
    const bottom = top + gap;
    pipes.push({ x: x, top: top, bottom: bottom, passed: false });
  }

  // cria canos iniciais VISÍVEIS (campo de obstáculos antes de iniciar)
  function spawnInitial(count = 5, spacing = 120){
    pipes = [];
    // Primeiro cano um pouco dentro da tela (visível)
    const startX = Math.floor(W - 40);
    for(let i=0;i<count;i++){
      spawnPipeAt(startX + i*spacing);
    }
  }

  // reinicia o jogo por completo (reset total)
  function fullReset(){
    // salvar melhor se necessário (se quiser salvar antes do reset, já foi feito no momento da colisão)
    score = 0;
    bird.y = H/2;
    bird.vy = 0;
    speed = 2.2;
    frame = 0;
    running = false; // pausa aguardando clique pra iniciar
    elPoints.textContent = score;
    // recria os canos para estado inicial (visíveis)
    spawnInitial(5, 120);
  }

  // collision circle vs rect
  function circleRect(cx, cy, r, rx, ry, rw, rh){
    const closestX = Math.max(rx, Math.min(cx, rx+rw));
    const closestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < r*r;
  }

  // chamada para quando o jogador bate
  function onHit(){
    // guarda melhor
    if(score > best){
      best = score;
      localStorage.setItem('flappy_best', best);
      elBest.textContent = best;
    }
    // faz um reset total imediato (volta ao começo)
    fullReset();
    // observe: o jogo fica pausado até o jogador clicar/toque/press Space
  }

  // input: flap / start
  function flap(){
    if(!running){
      // se estiver pausado, iniciar o jogo (estado limpo após reset)
      running = true;
      bird.vy = jump;
      return;
    }
    bird.vy = jump;
  }

  // listeners
  canvas.addEventListener('click', flap);
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); flap(); }, {passive:false});
  window.addEventListener('keydown', (e)=>{ if(e.code === 'Space'){ e.preventDefault(); flap(); }});

  // respawn inicial e estado pausado
  spawnInitial(5,120);

  // update
  function update(){
    if(!running) return; // enquanto pausado, não atualiza posição nem moves pipes
    frame++;
    // spawn novo cano periodicamente
    if(frame % 86 === 0){
      spawnPipeAt(W + 20);
    }

    // physics
    bird.vy += gravity;
    bird.y += bird.vy;

    // move pipes
    for(let p of pipes) p.x -= speed;

    // remove canos fora da tela
    while(pipes.length && pipes[0].x < -100) pipes.shift();

    // checar colisões e score
    for(let p of pipes){
      // colisão
      if(circleRect(bird.x, bird.y, bird.r, p.x, 0, 40, p.top) ||
         circleRect(bird.x, bird.y, bird.r, p.x, p.bottom, 40, H - p.bottom)){
        onHit();
        return; // sai do update; já resetou
      }
      // marcar passagem (pontuar)
      if(!p.passed && p.x + 40 < bird.x){
        p.passed = true;
        score++;
        elPoints.textContent = score;
        // aumentar dificuldade aos poucos
        if(score % 6 === 0) speed = clamp(speed + 0.25, 2.2, 6);
      }
    }

    // chão / teto
    if(bird.y + bird.r >= H || bird.y - bird.r <= 0){
      onHit();
      return;
    }
  }

  // draw
  function draw(){
    ctx.clearRect(0,0,W,H);
    // background
    ctx.fillStyle = '#70c5ce';
    ctx.fillRect(0,0,W,H);

    // nuvens decorativas
    ctx.fillStyle = '#cfeff3';
    ctx.beginPath(); ctx.ellipse(48 + Math.sin(frame/70)*8, 62, 36, 16, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(180 + Math.cos(frame/88)*10, 46, 44, 18, 0, 0, Math.PI*2); ctx.fill();

    // pipes
    for(let p of pipes){
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(Math.round(p.x), 0, 40, p.top);
      ctx.fillRect(Math.round(p.x), p.bottom, 40, H - p.bottom);
      // detalhes
      ctx.fillStyle = '#3f8a3f';
      ctx.fillRect(Math.round(p.x)+2, Math.max(0,p.top-8), 36, 8);
      ctx.fillRect(Math.round(p.x)+2, p.bottom, 36, 8);
    }

    // ground
    ctx.fillStyle = '#f3efe9';
    ctx.fillRect(0, H - 8, W, 8);

    // bird
    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(clamp(bird.vy/10, -0.8, 1.2));
    ctx.fillStyle = '#ffeb3b';
    ctx.beginPath(); ctx.arc(0,0,bird.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(6, -5, 3, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // overlay (quando pausado)
    if(!running){
      ctx.fillStyle = 'rgba(0,0,0,0.36)';
      ctx.fillRect(0,0,W,H);
      const pw = 260, ph = 130;
      const px = (W-pw)/2, py = (H-ph)/2;
      // painel branco
      ctx.fillStyle = '#fff';
      roundRect(ctx, px, py, pw, ph, 10, true);
      ctx.fillStyle = '#073b3b';
      ctx.textAlign = 'center';
      ctx.font = '18px Arial';
      if(score === 0){
        ctx.fillText('Clique para iniciar', W/2, py + 42);
        ctx.font = '14px Arial';
        ctx.fillText('Toque/Espaço para pular', W/2, py + 74);
      } else {
        ctx.fillText('Game Over', W/2, py + 36);
        ctx.font = '14px Arial';
        ctx.fillText('Pontos: ' + score, W/2, py + 68);
        ctx.fillText('Melhor: ' + best, W/2, py + 94);
      }
    }
  }

  function roundRect(ctx,x,y,w,h,r,fill){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fill) ctx.fill();
  }

  // main loop
  function loop(){
    update();
    draw();
    frame++;
    requestAnimationFrame(loop);
  }

  // start
  fullReset = fullReset || fullReset; // no-op to allow function hoisting / safe
  fullReset = fullReset || (()=>{}); // safety - will be replaced
  // define fullReset function reference properly
  // (we already defined fullReset above, but ensuring variable exists)
  // initialize
  fullReset = fullReset;
  fullReset = fullReset; // harmless
  // call the function defined earlier
  fullReset = (function(){ /* placeholder replaced by actual function */ return fullReset; })();

  // actually initialize by calling the defined fullReset implementation
  // (call the previously defined function)
  // but to be safe: call the reset logic directly:
  score = 0;
  bird.y = H/2;
  bird.vy = 0;
  speed = 2.2;
  frame = 0;
  running = false;
  spawnInitial(5,120);

  loop();

  // expose restart on click when paused (already handled by flap())
})();
</script>
</body>
</html>
