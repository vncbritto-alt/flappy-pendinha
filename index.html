<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Flappy Pendinha</title>

<style>
html,body{
  margin:0;
  padding:0;
  background:#70c5ce;
  font-family:Arial,Helvetica,sans-serif;
}

#gameContainer{
  position:relative;
  width:100%;
  max-width:520px;
  margin:20px auto;
}

canvas{
  width:100%;
  height:auto;
  background:#70c5ce;
  border-radius:10px;
  display:block;
  box-shadow:0 10px 30px rgba(0,0,0,.25);
}

/* BOTÃO FULLSCREEN */
#fullscreenBtn{
  position:absolute;
  top:10px;
  right:10px;
  z-index:10;
  background:rgba(0,0,0,.6);
  color:white;
  border:none;
  border-radius:6px;
  padding:6px 10px;
  cursor:pointer;
  font-size:16px;
}

#hud{
  display:flex;
  justify-content:space-between;
  margin-top:8px;
  font-weight:bold;
  color:#053033;
}
</style>
</head>

<body>

<div id="gameContainer">
  <button id="fullscreenBtn">⛶</button>
  <canvas id="game" width="360" height="520"></canvas>
</div>

<div id="hud">
  <div>Pontos: <span id="points">0</span></div>
  <div>Melhor: <span id="best">0</span></div>
</div>

<script>
/* ================= CONFIG ================= */
const CONFIG = {
  gravity: 0.35,
  jump: -8,
  gap: 190,
  speed: 2.2,
  pipeSpacing: 220,
  pipeWidth: 46,
  poolSize: 7,
  rankingMin: 100
};
/* ========================================= */

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

const elPoints = document.getElementById("points");
const elBest = document.getElementById("best");

let bird, pipes, running, score, best;

best = Number(localStorage.getItem("bestScore")) || 0;
elBest.textContent = best;

/* ---------- FULLSCREEN ---------- */
const fsBtn = document.getElementById("fullscreenBtn");
const container = document.getElementById("gameContainer");

fsBtn.onclick = () => {
  if(!document.fullscreenElement){
    container.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};
/* -------------------------------- */

/* ---------- GAME SETUP ---------- */
function resetGame(){
  bird = { x:90, y:H/2, r:18, vy:0 };
  pipes = [];
  score = 0;
  running = false;
  elPoints.textContent = score;

  let startX = W;
  for(let i=0;i<CONFIG.poolSize;i++){
    pipes.push(createPipe(startX + i * CONFIG.pipeSpacing));
  }
}

function createPipe(x){
  const top = Math.random()*(H/2 - 80) + 40;
  return {
    x,
    top,
    bottom: top + CONFIG.gap,
    passed:false
  };
}
/* -------------------------------- */

/* ---------- INPUT ---------- */
function flap(){
  if(!running){
    running = true;
  }
  bird.vy = CONFIG.jump;
}

canvas.addEventListener("click", flap);
window.addEventListener("keydown", e=>{
  if(e.code==="Space"){
    e.preventDefault();
    flap();
  }
});
/* -------------------------------- */

/* ---------- COLLISION ---------- */
function hitPipe(b,p){
  const r = CONFIG.pipeWidth;
  if(b.x + b.r > p.x && b.x - b.r < p.x + r){
    if(b.y - b.r < p.top || b.y + b.r > p.bottom){
      return true;
    }
  }
  return false;
}
/* -------------------------------- */

/* ---------- DRAW ---------- */
function drawBird(){
  ctx.save();
  ctx.translate(bird.x,bird.y);
  ctx.rotate(bird.vy/10);
  ctx.fillStyle="#ffeb3b";
  ctx.beginPath();
  ctx.ellipse(0,0,20,16,0,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle="#000";
  ctx.beginPath();
  ctx.arc(6,-5,3,0,Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawPipes(){
  for(const p of pipes){
    ctx.fillStyle="#3fa34b";
    ctx.fillRect(p.x,0,CONFIG.pipeWidth,p.top);
    ctx.fillRect(p.x,p.bottom,CONFIG.pipeWidth,H-p.bottom);
  }
}
/* -------------------------------- */

/* ---------- UPDATE ---------- */
function update(){
  if(!running) return;

  bird.vy += CONFIG.gravity;
  bird.y += bird.vy;

  for(const p of pipes){
    p.x -= CONFIG.speed;

    if(!p.passed && p.x + CONFIG.pipeWidth < bird.x){
      p.passed = true;
      score++;
      elPoints.textContent = score;
    }

    if(hitPipe(bird,p)){
      endGame();
      return;
    }
  }

  if(bird.y > H || bird.y < 0){
    endGame();
  }

  if(pipes[0].x < -CONFIG.pipeWidth){
    const lastX = pipes[pipes.length-1].x;
    pipes.shift();
    pipes.push(createPipe(lastX + CONFIG.pipeSpacing));
  }
}
/* -------------------------------- */

/* ---------- GAME OVER ---------- */
function endGame(){
  running = false;
  if(score > best){
    best = score;
    localStorage.setItem("bestScore",best);
    elBest.textContent = best;
  }

  if(score >= CONFIG.rankingMin){
    const name = prompt("Parabéns! Digite seu nome:");
    if(name){
      const rank = JSON.parse(localStorage.getItem("ranking")||"[]");
      rank.push({name,score});
      rank.sort((a,b)=>b.score-a.score);
      localStorage.setItem("ranking",JSON.stringify(rank.slice(0,10)));
    }
  }

  resetGame();
}
/* -------------------------------- */

/* ---------- LOOP ---------- */
function loop(){
  ctx.clearRect(0,0,W,H);
  drawPipes();
  drawBird();
  update();
  requestAnimationFrame(loop);
}
/* -------------------------------- */

resetGame();
loop();
</script>

</body>
</html>
